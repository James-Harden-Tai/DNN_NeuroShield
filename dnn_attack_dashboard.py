import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import os
import pickle
import re
from datetime import datetime
import networkx as nx
from PIL import Image
from concurrent.futures import ThreadPoolExecutor
# ========== 3Då¯è§†åŒ–ç›¸å…³ç±»ä¸å‡½æ•° BEGIN ==========
import json
import random
import math
import copy

# è·å–è„šæœ¬è‡ªèº«æ‰€åœ¨çš„ç›®å½•ï¼Œç”¨äºæ„å»ºç»å¯¹è·¯å¾„
_SCRIPT_DIR = os.path.dirname(__file__)

class NeuronInfo:
    def __init__(self, cluster_id, weights, singular_values, error):
        self.cluster_id = cluster_id
        self.weights = weights
        self.singular_values = singular_values
        self.error = error

def parse_neuron_data(lines):
    neurons = []
    current_cluster_id = None
    current_weights = None
    current_singular_values = None
    current_error = None
    for line in lines:
        line = line.strip()
        if line.startswith('CLUSTER ID'):
            current_cluster_id = int(line.split()[-1])
        elif line.startswith('Singular values'):
            try:
                values_str = line.split('[')[1].split(']')[0]
                current_singular_values = [float(x) for x in values_str.split()]
            except:
                pass
        elif line.startswith('Extracted weight vector'):
            try:
                weights_str = line.split('[')[1].split(']')[0]
                current_weights = [float(x) for x in weights_str.split()]
            except:
                pass
        elif 'abs err' in line:
            try:
                current_error = float(line.split('abs err')[-1].strip())
                if current_cluster_id is not None and current_weights is not None:
                    neurons.append(NeuronInfo(
                        current_cluster_id,
                        np.array(current_weights),
                        np.array(current_singular_values) if current_singular_values is not None else np.zeros(64),
                        current_error
                    ))
                    current_cluster_id = None
                    current_weights = None
                    current_singular_values = None
                    current_error = None
            except:
                pass
    return neurons

@st.cache_data
def load_weights(file_path):
    try:
        with open(file_path, 'r') as f:
            lines = f.readlines()
        neurons = parse_neuron_data(lines)
        if not neurons:
            return None
        if len(neurons) < 64:
            for i in range(len(neurons), 64):
                neurons.append(NeuronInfo(
                    i,
                    np.zeros(64),
                    np.zeros(64),
                    0.0
                ))
        elif len(neurons) > 64:
            neurons = neurons[:64]
        return neurons
    except Exception as e:
        return None

def load_weights_parallel(file_paths):
    with ThreadPoolExecutor() as executor:
        futures = [executor.submit(load_weights, file_path) for file_path in file_paths]
        return [future.result() for future in futures]

@st.cache_resource
def create_3d_network(_neurons_list, loaded_layers=None, show_all_connections=False, symbolic_data=None, is_final_view=False):
    import math
    fig = go.Figure()
    # ç»Ÿä¸€ä¸»è‰²è°ƒ
    main_color = '#00ff41'  # è§å…‰ç»¿
    inactive_color = '#222'  # æœªåŠ è½½æ·±ç°
    fail_color = '#ff2222'   # æ¢å¤å¤±è´¥äº®çº¢
    for layer_idx, neurons in enumerate(_neurons_list):
        if neurons is None:
            continue
        new_x_layer = -layer_idx * 12
        is_layer_loaded = loaded_layers is not None and layer_idx in loaded_layers
        # æå‰è®¡ç®—æœ€å¤§å¥‡å¼‚å€¼ä»¥æé«˜æ•ˆç‡å’Œå¥å£®æ€§
        all_svs = [n.singular_values[0] for n in neurons if len(n.singular_values) > 0]
        max_sv = max(all_svs) if all_svs else 1.0
        for i, neuron in enumerate(neurons):
            new_y_grid = (i % 8 - 3.5) * 1.5
            new_z_grid = (i // 8 - 3.5) * 1.5
            node_size = 7 + 10 * (neuron.singular_values[0] / max_sv if len(neuron.singular_values) > 0 else 0.5)
            node_color = main_color if is_layer_loaded else inactive_color
            symbolic_info = None
            if symbolic_data and (layer_idx, i) in symbolic_data:
                symbolic_info = symbolic_data[(layer_idx, i)]
                if symbolic_info.get('success'):
                    node_color = main_color
                    node_size = 8 + 15 * min(symbolic_info.get('ratio', 1.0) / 10, 1.0)
                else:
                    node_color = fail_color
                    node_size = 8  # å¤±è´¥èŠ‚ç‚¹å›ºå®šå¤§å°
            # --- ä¿®æ­£ï¼šç¡®ä¿node_sizeä¸ºåˆæ³•æ•°å€¼ ---
            if not isinstance(node_size, (int, float)) or math.isnan(node_size) or node_size <= 0:
                node_size = 10
            if is_final_view:
                # æœ€ç»ˆè§†å›¾çš„æ‚¬æµ®ä¿¡æ¯å¡ç‰‡ - "çŠ¶æ€æŠ¥å‘Š"
                hover_text = f'<span style="font-family: Orbitron, monospace; color:#0ff;">== FINAL STATUS ==</span><br>'
                hover_text += f'<b>Layer {layer_idx}, Neuron {i}</b><br>'
                hover_text += f'<br><b>Weight Recovery</b>: âœ… Success'
                hover_text += f'<br>  â”” Error: {neuron.error:.2e}'
                if symbolic_info:
                    if symbolic_info.get('success'):
                        hover_text += f'<br><b>Sign Recovery</b>: âœ… Success'
                        hover_text += f'<br>  â”” Confidence (dOFF/dON): {symbolic_info["ratio"]:.2f}'
                        hover_text += '<br><br><span style="color:#00ff41;"><b>STATUS: FULLY COMPROMISED</b></span>'
                    else:
                        hover_text += f'<br><b>Sign Recovery</b>: âŒ FAIL'
                        hover_text += f'<br>  â”” Confidence (dOFF/dON): -'
                        hover_text += '<br><br><span style="color:#ffc107;"><b>STATUS: PARTIALLY COMPROMISED</b></span>'
                else:
                    hover_text += '<br><b>Sign Recovery</b>: â” NOT RUN'
                    hover_text += '<br>  â”” Reason: No analysis data found'
                    hover_text += '<br><br><span style="color:#ffc107;"><b>STATUS: PARTIALLY COMPROMISED</b></span>'
            else:
                # é˜¶æ®µä¸€è§†å›¾çš„æ‚¬æµ®ä¿¡æ¯å¡ç‰‡ - "åŸå§‹æ•°æ®"
                hover_text = f'<span style="color:#00ff41;">Layer {layer_idx}, Neuron {i}</span><br>'
                hover_text += f'Cluster ID: {neuron.cluster_id}<br>'
                hover_text += f'Weight Error: {neuron.error:.2e}<br>'
                if len(neuron.singular_values) > 0:
                    hover_text += f'Max Singular Value: {neuron.singular_values[0]:.2f}'
                else:
                    hover_text += 'Max Singular Value: N/A'
                if symbolic_info:
                    hover_text += f'<br><br><b>--- Sign Recovery ---</b>'
                    if symbolic_info.get('success'):
                        hover_text += f'<br>Result: âœ… Success'
                        hover_text += f'<br>dOFF/dON Ratio: {symbolic_info["ratio"]:.2f}'
                        dxon = symbolic_info.get("dxONAngle", float('nan'))
                        dxoff = symbolic_info.get("dxOFFAngle", float('nan'))
                        hover_text += f'<br>ON/OFF Angles: {dxon:.1f}Â° / {dxoff:.1f}Â°'
                    else:
                        hover_text += f'<br>Result: âŒ Fail'
                        hover_text += f'<br>dOFF/dON Ratio: -'
                        hover_text += f'<br>ON/OFF Angles: - / -'
            fig.add_trace(go.Scatter3d(
                x=[new_x_layer], y=[new_y_grid], z=[new_z_grid],
                mode='markers',
                marker=dict(
                    size=node_size,
                    color=node_color,
                    line=dict(width=2, color=main_color),
                    opacity=0.92,
                ),
                name=f'Layer {layer_idx}',
                text=hover_text,
                hoverinfo='text',
            ))
            # è¿çº¿
            if layer_idx < len(_neurons_list) - 1 and _neurons_list[layer_idx + 1] is not None:
                next_neurons = _neurons_list[layer_idx + 1]
                if is_layer_loaded:
                    all_connections = []
                    for j, next_neuron in enumerate(next_neurons):
                        try:
                            if len(neuron.weights) != len(next_neuron.weights):
                                min_dim = min(len(neuron.weights), len(next_neuron.weights))
                                weight = np.dot(
                                    neuron.weights[:min_dim], 
                                    next_neuron.weights[:min_dim]
                                )
                            else:
                                weight = np.dot(neuron.weights, next_neuron.weights)
                            next_new_x_layer = -(layer_idx + 1) * 12
                            next_new_y_grid = (j % 8 - 3.5) * 1.5
                            next_new_z_grid = (j // 8 - 3.5) * 1.5
                            all_connections.append({
                                'x': [new_x_layer, next_new_x_layer],
                                'y': [new_y_grid, next_new_y_grid],
                                'z': [new_z_grid, next_new_z_grid],
                                'weight': weight,
                                'target_idx': j
                            })
                        except Exception as e:
                            continue
                    if not show_all_connections:
                        all_connections.sort(key=lambda x: abs(x['weight']), reverse=True)
                        connections_to_show = all_connections[:5]
                    else:
                        connections_to_show = all_connections
                    for conn in connections_to_show:
                        weight = conn['weight']
                        line_width = max(2, min(7, abs(weight) * 60))
                        line_color = 'rgba(0,255,65,0.3)' if weight >= 0 else 'rgba(255,0,80,0.2)'
                        fig.add_trace(go.Scatter3d(
                            x=conn['x'],
                            y=conn['y'],
                            z=conn['z'],
                            mode='lines',
                            line=dict(
                                color=line_color,
                                width=line_width,
                            ),
                            showlegend=False,
                            hoverinfo='skip',
                        ))
    fig.update_layout(
        scene=dict(
            xaxis=dict(
                title='Layer',
                zerolinewidth=2,
                showbackground=True,
                backgroundcolor='rgba(10,20,40,0.98)',
                range=[-48, 1],
                showgrid=False,
                zeroline=False,
                color=main_color,
            ),
            yaxis=dict(
                title='Y',
                zerolinewidth=2,
                showbackground=True,
                backgroundcolor='rgba(10,20,40,0.98)',
                range=[-6, 6],
                showgrid=False,
                zeroline=False,
                color=main_color,
            ),
            zaxis=dict(
                title='Z',
                zerolinewidth=2,
                showbackground=True,
                backgroundcolor='rgba(10,20,40,0.98)',
                range=[-6, 6],
                showgrid=False,
                zeroline=False,
                color=main_color,
            ),
            camera=dict(
                up=dict(x=0, y=0, z=1),
                center=dict(x=0, y=0, z=0),
                eye=dict(x=2.0, y=2.0, z=2.0),
            ),
        ),
        hoverlabel=dict(
            bgcolor="#000",
            font=dict(size=18, color=main_color),
            bordercolor=main_color,
            font_family="Fira Code, monospace"
        ),
        showlegend=True,
        legend=dict(
            yanchor="top",
            y=0.99,
            xanchor="left",
            x=0.01,
            bgcolor="rgba(0,0,0,0)",
            bordercolor="rgba(0,0,0,0)",
            font=dict(family="Fira Code, monospace", color=main_color),
            itemsizing='constant',
        ),
        margin=dict(l=0, r=0, t=30, b=0),
        width=1800,
        height=800,
        paper_bgcolor='#0c0c0c',
        plot_bgcolor='#0c0c0c',
        font=dict(family="Fira Code, monospace", color=main_color),
    )
    return fig

@st.cache_data
def load_symbolic_data():
    """åŠ è½½ç¬¦å·æ¢å¤æ•°æ®ï¼Œéå†src/layerID_*/neuronID_*ï¼Œå¯¹layerID_1æŒ‰æ¯64ä¸ªç¥ç»å…ƒåˆ†å±‚ç¼–å·ï¼Œå…¶ä»–layerID_*ä¿æŒåŸé€»è¾‘ã€‚"""
    import numpy as np
    symbolic_dict = {}
    src_path = os.path.join(_SCRIPT_DIR, 'src')

    def to_bool(val):
        if isinstance(val, (bool, np.bool_)):
            return bool(val)
        if isinstance(val, str):
            return val.strip().lower() == 'true'
        return False

    if not os.path.isdir(src_path):
        return symbolic_dict

    layers = sorted(
        [d for d in os.listdir(src_path) if d.startswith('layerID_') and os.path.isdir(os.path.join(src_path, d))],
        key=lambda name: int(re.search(r'\d+', name).group())
    )

    for layer_name in layers:
        layer_path = os.path.join(src_path, layer_name)
        layer_id = int(re.search(r'\d+', layer_name).group())

        neurons_in_layer = sorted(
            [n for n in os.listdir(layer_path) if n.startswith('neuronID_') and os.path.isdir(os.path.join(layer_path, n))],
            key=lambda name: int(re.search(r'\d+', name).group())
        )
        neuron_ids = [int(re.search(r'\d+', n).group()) for n in neurons_in_layer]

        for neuron_dir in neurons_in_layer:
            neuron_id_raw = int(re.search(r'\d+', neuron_dir).group())
            df_path = os.path.join(layer_path, neuron_dir, 'df.csv')

            # layerID_1ç‰¹æ®Šæ˜ å°„
            if layer_id == 1:
                real_layer = neuron_id_raw // 64
                real_neuron = neuron_id_raw % 64
                key = (real_layer, real_neuron)
            else:
                key = (layer_id, neuron_id_raw)
            symbolic_dict[key] = {'success': False}

            # --- åˆ é™¤è°ƒè¯•expanderåŠå…¶å†…éƒ¨å†…å®¹ ---
            # åªä¿ç•™å®é™…æ•°æ®å¤„ç†é€»è¾‘

            if os.path.isfile(df_path) and os.path.getsize(df_path) > 0:
                try:
                    df = pd.read_csv(df_path)
                    df.columns = df.columns.str.strip()
                    if 'SUCCESS' in df.columns:
                        true_rows = df[df['SUCCESS'].apply(to_bool)]
                        if not true_rows.empty:
                            latest_true_row = true_rows.iloc[-1]
                            # ä¼˜å…ˆç”¨'dOFF/dON'ï¼Œæ²¡æœ‰å†ç”¨'ratio'
                            ratio = float('nan')
                            for col in ['dOFF/dON', 'ratio']:
                                if col in latest_true_row and not pd.isna(latest_true_row[col]):
                                    ratio = latest_true_row[col]
                                    break
                            symbolic_dict[key] = {
                                'success': True,
                                'ratio': ratio,
                                'dxONAngle': latest_true_row.get('dxONAngle', float('nan')),
                                'dxOFFAngle': latest_true_row.get('dxOFFAngle', float('nan')),
                            }
                except Exception:
                    pass
    return symbolic_dict

# --- æ¨¡æ‹Ÿæ•°æ®ç”Ÿæˆå‡½æ•° (ç”¨äºæ¼”ç¤º) ---
def generate_mock_neurons_list(num_layers=4, neurons_per_layer=64):
    """ç”Ÿæˆæ¨¡æ‹Ÿçš„ç¥ç»å…ƒæƒé‡æ•°æ®åˆ—è¡¨"""
    neurons_list = []
    for _ in range(num_layers):
        layer_neurons = []
        for i in range(neurons_per_layer):
            # åˆ›å»ºå¤–è§‚çœŸå®çš„æ•°æ®
            mock_weights = np.random.rand(64)
            mock_svs = np.sort(np.random.rand(5) * 200)[::-1] # æ¨¡æ‹Ÿæœ€å¤§çš„å‡ ä¸ªå¥‡å¼‚å€¼
            mock_error = np.random.uniform(1e-8, 5e-7)
            
            layer_neurons.append(NeuronInfo(
                cluster_id=i,
                weights=mock_weights,
                singular_values=mock_svs,
                error=mock_error
            ))
        neurons_list.append(layer_neurons)
    return neurons_list

def generate_mock_symbolic_data(num_layers=4, neurons_per_layer=64, failure_rate=0.15):
    """ç”Ÿæˆæ¨¡æ‹Ÿçš„ç¬¦å·æ¢å¤ç»“æœå­—å…¸"""
    symbolic_dict = {}
    for l_idx in range(num_layers):
        for n_idx in range(neurons_per_layer):
            # éšæœºå†³å®šè¯¥ç¥ç»å…ƒæ˜¯å¦æœ‰ç¬¦å·æ¢å¤æ•°æ®
            if random.random() < 0.98: # 98%çš„ç¥ç»å…ƒæœ‰æ•°æ®
                is_success = random.random() > failure_rate
                if is_success:
                    ratio = random.uniform(1.5, 10.0)
                else:
                    ratio = random.uniform(0.8, 1.2)
                
                symbolic_dict[(l_idx, n_idx)] = {
                    'success': is_success,
                    'ratio': ratio,
                    'dxONAngle': random.uniform(5, 40),
                    'dxOFFAngle': random.uniform(5, 40),
                    'dON': random.uniform(0.1, 0.5),
                    'dOFF': random.uniform(0.5, 2.5),
                    'layer_name': f'layerID_{l_idx}',
                    'neuron_name': f'neuronID_{n_idx}'
                }
    return symbolic_dict
# --- æ¨¡æ‹Ÿæ•°æ®ç”Ÿæˆç»“æŸ ---


# ====== å·¥å…·å‡½æ•°åŒº ======
import copy, random

def get_simulated_data(defense, base_neurons_list, base_symbolic_data):
    """
    æ ¹æ®é˜²å¾¡ç±»å‹å¯¹åŸå§‹æ•°æ®åšé™æˆåŠŸç‡å¤„ç†ï¼Œè¿”å›æ–°çš„ neurons_list, symbolic_dataã€‚
    """
    defense_success = {
        "æ— é˜²å¾¡": (0.95, 0.95),
        "è¾“å‡ºæ‰°åŠ¨": (0.60, 0.60),
        "è¾“å…¥å˜æ¢": (0.50, 0.40),
        "æ¨¡å‹å‚æ•°æ‰°åŠ¨": (0.30, 0.25)
    }
    weight_rate, sign_rate = defense_success.get(defense, (0.95, 0.95))
    neurons_list = copy.deepcopy(base_neurons_list)
    for layer in neurons_list:
        if layer is None:
            continue
        for neuron in layer:
            if random.random() > weight_rate:
                neuron.error = neuron.error * random.uniform(2, 5) + random.uniform(0.1, 1)
                neuron.singular_values = [0.0 for _ in neuron.singular_values]
    symbolic_data = copy.deepcopy(base_symbolic_data)
    for key, val in symbolic_data.items():
        if random.random() > sign_rate:
            val['success'] = False
            val['ratio'] = random.uniform(0.5, 0.99)
            val['dxONAngle'] = random.uniform(80, 100)
            val['dxOFFAngle'] = random.uniform(80, 100)
    return neurons_list, symbolic_data


@st.cache_resource
def create_2d_network_graph(_neurons_list, _symbolic_data=None):
    G = nx.Graph()
    node_text = {}
    node_color = {}
    
    # Subsample neurons for display if layers are too large
    display_neurons = {}
    for i, neurons in enumerate(_neurons_list):
        if neurons:
            if len(neurons) > 30:
                # Use linspace to get evenly spaced neurons
                indices = np.linspace(0, len(neurons) - 1, 30, dtype=int)
                display_neurons[i] = indices
            else:
                display_neurons[i] = range(len(neurons))

    # Add nodes
    for layer_idx, neurons in enumerate(_neurons_list):
        if not neurons:
            continue
        for neuron_idx in display_neurons.get(layer_idx, []):
            node_id = f'{layer_idx}_{neuron_idx}'
            G.add_node(node_id, layer=layer_idx)
            
            symbolic_info = _symbolic_data.get((layer_idx, neuron_idx))
            color = '#00ff41' # Main color
            if symbolic_info and not symbolic_info['success']:
                color = '#ff2222' # Fail color
            node_color[node_id] = color

            text = f'Layer {layer_idx}, Neuron {neuron_idx}'
            if symbolic_info:
                text += f'<br>Symbolic Recovery: {"æˆåŠŸ" if symbolic_info["success"] else "å¤±è´¥"}'
            node_text[node_id] = text

    # Add edges
    for layer_idx in range(len(_neurons_list) - 1):
        if _neurons_list[layer_idx] and _neurons_list[layer_idx+1]:
            # Ensure both layers have neurons to display
            if layer_idx in display_neurons and (layer_idx + 1) in display_neurons:
                for u_idx in display_neurons[layer_idx]:
                    for v_idx in display_neurons[layer_idx + 1]:
                        # Connect with some probability to avoid clutter
                        if np.random.rand() < 5.0 / len(display_neurons[layer_idx + 1]):
                            u = f'{layer_idx}_{u_idx}'
                            v = f'{layer_idx + 1}_{v_idx}'
                            G.add_edge(u, v)

    if not G.nodes():
        return go.Figure()

    # Get positions using multipartite layout
    pos = nx.multipartite_layout(G, subset_key="layer")

    edge_x = []
    edge_y = []
    for edge in G.edges():
        x0, y0 = pos[edge[0]]
        x1, y1 = pos[edge[1]]
        edge_x.extend([x0, x1, None])
        edge_y.extend([y0, y1, None])

    edge_trace = go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=0.5, color='rgba(0,255,65,0.3)'),
        hoverinfo='none',
        mode='lines')

    node_x = []
    node_y = []
    texts = []
    colors = []
    for node in G.nodes():
        x, y = pos[node]
        node_x.append(x)
        node_y.append(y)
        texts.append(node_text.get(node, ''))
        colors.append(node_color.get(node, '#222'))

    node_trace = go.Scatter(
        x=node_x, y=node_y,
        mode='markers',
        hoverinfo='text',
        text=texts,
        marker=dict(
            color=colors,
            size=10,
            line=dict(width=2, color='#00ff41')
        ))

    fig = go.Figure(data=[edge_trace, node_trace],
             layout=go.Layout(
                showlegend=False,
                hovermode='closest',
                margin=dict(b=0, l=0, r=0, t=40),
                xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
                paper_bgcolor='#0c0c0c',
                plot_bgcolor='#0c0c0c',
                font=dict(family="Fira Code, monospace", color='#00ff41'),
                height=600,
                 hoverlabel=dict(
                    bgcolor="#000",
                    font=dict(size=14, color='#00ff41'),
                    bordercolor='#00ff41',
                    font_family="Fira Code, monospace"
                ),
             ))
    return fig

# ========== 3Då¯è§†åŒ–ç›¸å…³ç±»ä¸å‡½æ•° END ========== 

# è®¾ç½®é¡µé¢é…ç½®
st.set_page_config(
    page_title="NeuroShield--é¢å‘ç¡¬æ ‡ç­¾åœºæ™¯çš„æ·±åº¦ç¥ç»ç½‘ç»œæŠ—æå–é˜²å¾¡ç³»ç»Ÿ",
    page_icon="ğŸ§ ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# è‡ªå®šä¹‰CSS - ç§‘æŠ€æ„Ÿé»‘å®¢é£æ ¼
st.markdown("""
<style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Fira+Code:wght@300;400;500&display=swap');
    
    /* å…¨å±€æ ·å¼ */
    .stApp {
        background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
        color: #00ff41;
    }
    
    /* éšè—streamlité»˜è®¤å…ƒç´  */
    #MainMenu {visibility: hidden;}
    footer {visibility: hidden;}
    header {visibility: hidden;}
    
    /* ä¸»æ ‡é¢˜ */
    .main-header {
        font-family: 'Orbitron', monospace;
        font-size: 3rem;
        font-weight: 900;
        background: linear-gradient(45deg, #00ff41, #0ff, #f0f);
        background-size: 400% 400%;
        animation: gradient 3s ease infinite;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-align: center;
        margin-bottom: 2rem;
        text-shadow: 0 0 20px rgba(0,255,65,0.5);
    }
    
    @keyframes gradient {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }
    
    /* å¯¼èˆªæŒ‰é’®ç»„ */
    .nav-container {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 10px;
        margin: 2rem 0;
        padding: 1rem;
        background: rgba(0,0,0,0.3);
        border-radius: 15px;
        border: 1px solid rgba(0,255,65,0.3);
        backdrop-filter: blur(10px);
    }
    
    .nav-button {
        background: linear-gradient(45deg, rgba(0,255,65,0.1), rgba(0,255,255,0.1));
        border: 2px solid #00ff41;
        color: #00ff41;
        padding: 12px 20px;
        border-radius: 25px;
        font-family: 'Orbitron', monospace;
        font-weight: 700;
        font-size: 0.9rem;
        cursor: pointer;
        transition: all 0.3s ease;
        text-decoration: none;
        display: inline-block;
        position: relative;
        overflow: hidden;
        box-shadow: 0 0 15px rgba(0,255,65,0.3);
    }
    
    .nav-button:hover {
        background: linear-gradient(45deg, rgba(0,255,65,0.3), rgba(0,255,255,0.3));
        box-shadow: 0 0 25px rgba(0,255,65,0.6);
        transform: translateY(-2px);
        color: #ffffff;
    }
    
    .nav-button.active {
        background: linear-gradient(45deg, #00ff41, #0ff);
        color: #000;
        box-shadow: 0 0 30px rgba(0,255,65,0.8);
    }
    
    /* æ”»å‡»é˜¶æ®µæ ‡é¢˜ */
    .attack-phase {
        background: linear-gradient(90deg, #ff0040, #ff6b00, #00ff41);
        background-size: 300% 300%;
        animation: gradientShift 2s ease infinite;
        color: #000;
        padding: 1.5rem;
        border-radius: 15px;
        margin: 2rem 0;
        text-align: center;
        font-family: 'Orbitron', monospace;
        font-weight: 900;
        font-size: 1.3rem;
        border: 2px solid rgba(255,255,255,0.3);
        box-shadow: 0 0 30px rgba(0,255,65,0.4);
        text-transform: uppercase;
        letter-spacing: 2px;
    }
    
    @keyframes gradientShift {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }
    
    /* æŒ‡æ ‡å¡ç‰‡ */
    .metric-card {
        background: rgba(0,0,0,0.7);
        border: 2px solid #00ff41;
        border-radius: 15px;
        padding: 1.5rem;
        margin: 1rem;
        text-align: center;
        font-family: 'Fira Code', monospace;
        box-shadow: 0 0 20px rgba(0,255,65,0.4);
        backdrop-filter: blur(10px);
        transition: all 0.3s ease;
    }
    
    .metric-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 0 30px rgba(0,255,65,0.7);
    }
    
    .success-metric {
        background: linear-gradient(135deg, rgba(0,255,65,0.2), rgba(0,255,255,0.2));
        border: 2px solid #00ff41;
        color: #00ff41;
        padding: 1.5rem;
        border-radius: 15px;
        margin: 0.5rem;
        text-align: center;
        font-family: 'Orbitron', monospace;
        font-weight: 700;
        box-shadow: 0 0 20px rgba(0,255,65,0.5);
        backdrop-filter: blur(10px);
    }
    
    .danger-metric {
        background: linear-gradient(135deg, rgba(255,0,64,0.2), rgba(255,107,0,0.2));
        border: 2px solid #ff0040;
        color: #ff0040;
        padding: 1.5rem;
        border-radius: 15px;
        margin: 0.5rem;
        text-align: center;
        font-family: 'Orbitron', monospace;
        font-weight: 700;
        box-shadow: 0 0 20px rgba(255,0,64,0.5);
        backdrop-filter: blur(10px);
    }
    
    .warning-metric {
        background: linear-gradient(135deg, rgba(255,193,7,0.2), rgba(255,152,0,0.2));
        border: 2px solid #ffc107;
        color: #ffc107;
        padding: 1.5rem;
        border-radius: 15px;
        margin: 0.5rem;
        text-align: center;
        font-family: 'Orbitron', monospace;
        font-weight: 700;
        box-shadow: 0 0 20px rgba(255,193,7,0.5);
        backdrop-filter: blur(10px);
    }
    
    /* ä¿¡æ¯æ¡† */
    .info-box {
        background: rgba(0,0,0,0.6);
        border: 1px solid rgba(0,255,65,0.5);
        border-left: 5px solid #00ff41;
        padding: 1.5rem;
        margin: 1rem 0;
        border-radius: 10px;
        font-family: 'Fira Code', monospace;
        color: #00ff41;
        backdrop-filter: blur(10px);
        box-shadow: 0 0 15px rgba(0,255,65,0.3);
    }
    
    .hacker-box {
        background: rgba(0,0,0,0.8);
        border: 2px solid #ff0040;
        border-radius: 10px;
        padding: 1.5rem;
        margin: 1rem 0;
        font-family: 'Fira Code', monospace;
        color: #ff0040;
        position: relative;
        overflow: hidden;
    }
    
    .hacker-box::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,0,64,0.1), transparent);
        animation: scan 2s infinite;
    }
    
    @keyframes scan {
        0% { left: -100%; }
        100% { left: 100%; }
    }
    
    /* å­æ ‡é¢˜ */
    .sub-header {
        font-family: 'Orbitron', monospace;
        font-size: 1.8rem;
        color: #0ff;
        margin-bottom: 1rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        text-shadow: 0 0 10px rgba(0,255,255,0.5);
    }
    
    /* Streamlitå…ƒç´ è‡ªå®šä¹‰ */
    .stSelectbox > div > div {
        background-color: rgba(0,0,0,0.7);
        border: 2px solid #00ff41;
        border-radius: 10px;
        color: #00ff41;
    }
    
    .stMetric {
        background: rgba(0,0,0,0.7);
        border: 1px solid rgba(0,255,65,0.3);
        border-radius: 10px;
        padding: 1rem;
        backdrop-filter: blur(10px);
    }
    
    /* è‡ªå®šä¹‰æŒ‰é’®æ ·å¼ */
    .stButton > button {
        background: linear-gradient(45deg, rgba(0,255,65,0.1), rgba(0,255,255,0.1));
        border: 2px solid #00ff41 !important;
        border-radius: 15px !important;
        color: #00ff41 !important;
        font-family: 'Orbitron', monospace !important;
        font-weight: 700 !important;
        transition: all 0.3s ease !important;
        box-shadow: 0 0 15px rgba(0,255,65,0.3) !important;
        backdrop-filter: blur(10px);
    }
    
    .stButton > button:hover {
        background: linear-gradient(45deg, rgba(0,255,65,0.3), rgba(0,255,255,0.3)) !important;
        box-shadow: 0 0 25px rgba(0,255,65,0.6) !important;
        transform: translateY(-2px) !important;
        border-color: #0ff !important;
        color: #ffffff !important;
    }
    
    .stButton > button:active, .stButton > button:focus {
        background: linear-gradient(45deg, #00ff41, #0ff) !important;
        color: #000 !important;
        box-shadow: 0 0 30px rgba(0,255,65,0.8) !important;
    }
    
    /* PrimaryæŒ‰é’®æ ·å¼ï¼ˆæ¿€æ´»çŠ¶æ€ï¼‰ */
    div[data-testid="column"] .stButton > button[kind="primary"] {
        background: linear-gradient(45deg, #00ff41, #0ff) !important;
        color: #000 !important;
        box-shadow: 0 0 30px rgba(0,255,65,0.8) !important;
        border: 2px solid #ffffff !important;
    }
    
    /* ä¾§è¾¹æ æ ·å¼ */
    .css-1d391kg {
        background: linear-gradient(180deg, #0c0c0c 0%, #1a1a2e 100%);
    }
    
    /* ç»ˆç«¯æ•ˆæœæ–‡æœ¬ */
    .terminal-text {
        font-family: 'Fira Code', monospace;
        background: #000;
        color: #00ff41;
        padding: 1rem;
        border-radius: 5px;
        border: 1px solid #00ff41;
        margin: 1rem 0;
        font-size: 0.9rem;
        line-height: 1.4;
        overflow-x: auto;
    }
    
    .glitch {
        position: relative;
        color: #00ff41;
        font-family: 'Orbitron', monospace;
        font-weight: 700;
        animation: glitch 0.3s infinite linear alternate-reverse;
    }
    
    @keyframes glitch {
        0% { text-shadow: 1px 0 0 #ff0040, -1px 0 0 #0ff; }
        15% { text-shadow: 1px 0 0 #ff0040, -1px 0 0 #0ff; }
        16% { text-shadow: -1px 0 0 #ff0040, 1px 0 0 #0ff; }
        49% { text-shadow: -1px 0 0 #ff0040, 1px 0 0 #0ff; }
        50% { text-shadow: 1px 0 0 #ff0040, -1px 0 0 #0ff; }
        99% { text-shadow: 1px 0 0 #ff0040, -1px 0 0 #0ff; }
        100% { text-shadow: -1px 0 0 #ff0040, 1px 0 0 #0ff; }
    }
    
    /* é¡µè„šæ ·å¼ */
    .footer {
        text-align: center;
        color: #666;
        font-family: 'Fira Code', monospace;
        font-size: 0.8rem;
        padding: 2rem;
        border-top: 1px solid rgba(0,255,65,0.3);
        margin-top: 3rem;
        background: rgba(0,0,0,0.5);
    }
    
    .footer a {
        color: #00ff41;
        text-decoration: none;
    }
    
    .footer a:hover {
        color: #0ff;
        text-shadow: 0 0 5px rgba(0,255,255,0.5);
    }
    
    /* æˆåŠŸæ¡†æ ·å¼ */
    .success-box {
        background: linear-gradient(135deg, rgba(0,255,65,0.1), rgba(0,255,255,0.1));
        border: 2px solid #00ff41;
        border-radius: 15px;
        padding: 1.5rem;
        margin: 1rem 0;
        color: #00ff41;
        box-shadow: 0 0 25px rgba(0,255,65,0.4);
        animation: successGlow 2s ease-in-out infinite alternate;
        font-family: 'Orbitron', monospace;
        backdrop-filter: blur(10px);
    }
    
    .success-box h4 {
        color: #0ff;
        margin-bottom: 1rem;
        text-shadow: 0 0 10px rgba(0,255,255,0.5);
    }
    
    .success-box ul li {
        margin: 0.5rem 0;
        list-style: none;
        padding-left: 1rem;
    }
    
    @keyframes successGlow {
        from { 
            box-shadow: 0 0 25px rgba(0,255,65,0.4);
            border-color: #00ff41;
        }
        to { 
            box-shadow: 0 0 35px rgba(0,255,65,0.6);
            border-color: #0ff;
        }
    }
</style>
""", unsafe_allow_html=True)

# ä¸»æ ‡é¢˜
st.markdown('<h1 class="main-header">âš¡ NEURAL NETWORK EXTRACTION</h1>', unsafe_allow_html=True)
st.markdown('<div style="text-align: center; font-family: \'Fira Code\', monospace; color: #00ff41; margin-bottom: 2rem; font-size: 2.2rem; font-weight: bold; letter-spacing: 1px;">[ <span style="font-family: Orbitron, monospace; font-weight:900;">NeuroShield</span>--é¢å‘ç¡¬æ ‡ç­¾åœºæ™¯çš„æ·±åº¦ç¥ç»ç½‘ç»œæŠ—æå–é˜²å¾¡ç³»ç»Ÿ ]</div>', unsafe_allow_html=True)

# é¡¹ç›®ä»‹ç»
with st.expander("ğŸ›¡ï¸ [ CLASSIFIED ] é¡¹ç›®æœºå¯†æ¡£æ¡ˆ", expanded=False):
    st.markdown("""
    <div class="terminal-text">
    > ACCESSING CLASSIFIED DATABASE...
    > AUTHENTICATION: SUCCESS
    > LOADING PROJECT FILES...
    
    === NEURAL NETWORK EXTRACTION PROJECT ===
    
    ğŸ“‹ MISSION OVERVIEW:
    åŸºäº EUROCRYPT 2024 è®ºæ–‡çš„ç¥ç»ç½‘ç»œå‚æ•°æå–æ”»å‡»
    "Polynomial Time Cryptanalytic Extraction of Deep Neural Networks"
    
    ğŸ¯ TARGET SPECIFICATIONS:
    - TARGET: CIFAR-10 Neural Network (3-Layer Architecture)
    - ACCURACY: 52% (Deliberately Vulnerable)
    - ATTACK TYPE: Hard-Label Setting Parameter Extraction
    - OBJECTIVE: Complete Weight & Sign Recovery
    
    âš”ï¸ ATTACK METHODOLOGY:
    [PHASE 1] SIGNATURE_RECOVERY.exe
    â””â”€â”€ Dual Point Detection & Clustering
    â””â”€â”€ Weight Vector Extraction (Unsigned)
    
    [PHASE 2] SIGN_RECOVERY.exe  
    â””â”€â”€ Statistical Analysis of Neuron Activation
    â””â”€â”€ Weight Sign Determination
    
    [RESULT] COMPLETE_MODEL_RECONSTRUCTION.exe
    â””â”€â”€ Full Parameter Recovery Achieved
    â””â”€â”€ Backdoor Injection Capability Unlocked
    </div>
    """, unsafe_allow_html=True)

# å¯¼èˆªæŒ‰é’®ç»„
st.markdown("""
<div class="nav-container">
    <div id="nav-overview" class="nav-button" onclick="selectPhase('ğŸ¯ æ”»å‡»æ¦‚è§ˆ')">
        ğŸ¯ OVERVIEW
    </div>
    <div id="nav-phase1" class="nav-button" onclick="selectPhase('âš¡ ç¬¬ä¸€é˜¶æ®µï¼šæƒé‡æ¢å¤')">
        âš¡ PHASE 1: WEIGHTS
    </div>
    <div id="nav-phase2" class="nav-button" onclick="selectPhase('ğŸ” ç¬¬äºŒé˜¶æ®µï¼šç¬¦å·æ¢å¤')">
        ğŸ” PHASE 2: SIGNS
    </div>
    <div id="nav-3d" class="nav-button" onclick="selectPhase('ğŸŒ 3Dç½‘ç»œå¯è§†åŒ–')">
        ğŸŒ 3D NETWORK
    </div>
    <div id="nav-analysis" class="nav-button" onclick="selectPhase('ğŸ“Š æ”»å‡»æ•ˆæœåˆ†æ')">
        ğŸ“Š ANALYSIS
    </div>
    <div id="nav-defense" class="nav-button" onclick="selectPhase('ğŸ›¡ï¸ é˜²å¾¡æ–¹å¼')">
        ğŸ›¡ï¸ DEFENSE
    </div>
</div>

<script>
function selectPhase(phase) {
    // ç§»é™¤æ‰€æœ‰æ´»è·ƒçŠ¶æ€
    document.querySelectorAll('.nav-button').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // æ·»åŠ æ´»è·ƒçŠ¶æ€åˆ°å½“å‰æŒ‰é’®
    event.target.classList.add('active');
}
</script>
""", unsafe_allow_html=True)

# ä¾§è¾¹æ æ§åˆ¶ - ç§»é™¤åŸæ¥çš„selectboxï¼Œæ”¹ä¸ºçŠ¶æ€æ˜¾ç¤º
st.sidebar.markdown('<div class="glitch">âš¡ ATTACK CONSOLE</div>', unsafe_allow_html=True)

# åŠ è½½æ•°æ®çš„å‡½æ•°
@st.cache_data
def load_weight_recovery_logs():
    """åŠ è½½æƒé‡æ¢å¤æ—¥å¿—"""
    logs_dir = os.path.join(_SCRIPT_DIR, "src", "logs")
    log_data = {}
    
    if os.path.exists(logs_dir):
        for filename in os.listdir(logs_dir):
            if filename.endswith('.log'):
                layer_match = re.search(r'layer_(\d+)', filename)
                if layer_match:
                    layer_id = int(layer_match.group(1))
                    filepath = os.path.join(logs_dir, filename)
                    
                    with open(filepath, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    # è§£ææ—¥å¿—å†…å®¹
                    neurons_extracted = len(re.findall(r'Successfully extracted neuron \d+ with abs err', content))
                    cluster_ids = re.findall(r'CLUSTER ID (\d+)', content)
                    errors = re.findall(r'abs err ([\d.e-]+)', content)
                    
                    # ç¡®ä¿æ•°æ®ä¸€è‡´æ€§
                    cluster_ids = [int(x) for x in cluster_ids]
                    errors = [float(x) for x in errors]
                    
                    # å¦‚æœé•¿åº¦ä¸åŒ¹é…ï¼Œå–è¾ƒçŸ­çš„é•¿åº¦
                    if len(cluster_ids) != len(errors):
                        min_len = min(len(cluster_ids), len(errors))
                        cluster_ids = cluster_ids[:min_len]
                        errors = errors[:min_len]
                    
                    log_data[layer_id] = {
                        'neurons_extracted': neurons_extracted,
                        'cluster_ids': cluster_ids,
                        'errors': errors,
                        'filename': filename
                    }
    
    return log_data

@st.cache_data
def load_sign_recovery_data():
    """åŠ è½½ç¬¦å·æ¢å¤æ•°æ®ï¼ŒåŠ¨æ€æ‰«æsrcç›®å½•å¹¶è¿›è¡Œæ•°å­—æ’åº"""
    sign_data = {}
    src_path = os.path.join(_SCRIPT_DIR, 'src')

    if not os.path.isdir(src_path):
        st.warning(f"è­¦å‘Š: æ‰¾ä¸åˆ°æ•°æ®ç›®å½• '{src_path}'ã€‚ç¬¦å·æ¢å¤æ•°æ®å°†æ— æ³•åŠ è½½ã€‚")
        return sign_data

    # ä¿®å¤1: ä½¿ç”¨æ•°å­—æ’åºè€Œä¸æ˜¯å­—æ¯æ’åº
    layer_dirs = sorted(
        [d for d in os.listdir(src_path) if d.startswith('layerID_') and os.path.isdir(os.path.join(src_path, d))],
        key=lambda name: int(re.search(r'\d+', name).group())
    )
    
    for layer_dirname in layer_dirs:
        layer_dir = os.path.join(src_path, layer_dirname)
        layer_id_match = re.search(r'\d+$', layer_dirname)
        if not layer_id_match: continue
        layer_id = int(layer_id_match.group(0))
        
        sign_data[layer_id] = {}
        
        neuron_dirs = sorted(
            [d for d in os.listdir(layer_dir) if d.startswith('neuronID_')],
            key=lambda name: int(re.search(r'\d+', name).group())
        )
        
        for neuron_dir in neuron_dirs:
            neuron_id_match = re.search(r'\d+$', neuron_dir)
            if not neuron_id_match: continue
            neuron_id = int(neuron_id_match.group(0))
            
            neuron_path = os.path.join(layer_dir, neuron_dir)
            csv_path = os.path.join(neuron_path, 'df.csv')

            if os.path.exists(csv_path):
                try:
                    df = pd.read_csv(csv_path)
                    # ä¿®å¤2: å¢åŠ å¥å£®æ€§ï¼Œå¤„ç†ç©ºdf.csvæ–‡ä»¶
                    if not df.empty and all(col in df.columns for col in ['Vote dOFF>dON', 'dOFF/dON']):
                        total_experiments = len(df)
                        successful_votes = len(df[df['Vote dOFF>dON'] == True])
                        success_rate = successful_votes / total_experiments if total_experiments > 0 else 0
                        avg_ratio = df['dOFF/dON'].mean() if not df['dOFF/dON'].empty else 0
                        
                        sign_data[layer_id][neuron_id] = {
                            'success_rate': success_rate,
                            'total_experiments': total_experiments,
                            'successful_votes': successful_votes,
                            'avg_ratio': avg_ratio,
                            'data': df
                        }
                except pd.errors.EmptyDataError:
                    # æ–‡ä»¶æ˜¯ç©ºçš„ï¼Œè¿™æ˜¯é¢„æœŸçš„å¤±è´¥æƒ…å†µï¼Œç›´æ¥è·³è¿‡
                    continue
                except Exception as e:
                    # æ‰“å°å…¶ä»–æœªçŸ¥é”™è¯¯ï¼Œè€Œä¸æ˜¯é»˜é»˜è·³è¿‡
                    print(f"å¤„ç†æ–‡ä»¶ {csv_path} æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}")
                    continue
    return sign_data

# åŠ è½½æ•°æ®
weight_data = load_weight_recovery_logs()
sign_data = load_sign_recovery_data()

# æ”»å‡»é˜¶æ®µé€‰æ‹© - ä½¿ç”¨session stateç®¡ç†çŠ¶æ€
if 'attack_phase' not in st.session_state:
    st.session_state.attack_phase = "ğŸ¯ æ”»å‡»æ¦‚è§ˆ"

# ä¾§è¾¹æ æ§åˆ¶æŒ‰é’®
st.sidebar.markdown("### ğŸ® CONTROL PANEL")

# åˆ›å»ºå¯¼èˆªæŒ‰é’®
phases = [
    ("ğŸ›¡ï¸", "é˜²å¾¡å¯¹æ¯”", "Defense measures and their effects"),
    ("âš¡", "æƒé‡æ¢å¤", "PHASE 1"),
    ("ğŸ”", "ç¬¦å·æ¢å¤", "PHASE 2"), 
    ("ğŸ›°ï¸", "æœ€ç»ˆç½‘ç»œ", "FINAL VIEW"),
    ("ğŸ“Š", "æ•ˆæœåˆ†æ", "ANALYSIS"),
]

for emoji, phase_cn, phase_en in phases:
    phase_key = f"{emoji} ç¬¬ä¸€é˜¶æ®µï¼šæƒé‡æ¢å¤" if "æƒé‡" in phase_cn else f"{emoji} ç¬¬äºŒé˜¶æ®µï¼šç¬¦å·æ¢å¤" if "ç¬¦å·" in phase_cn else f"{emoji} æœ€ç»ˆç½‘ç»œ" if "æœ€ç»ˆç½‘ç»œ" in phase_cn else f"{emoji} æ”»å‡»æ•ˆæœåˆ†æ" if "æ•ˆæœ" in phase_cn else f"{emoji} é˜²å¾¡å¯¹æ¯”" if "é˜²å¾¡" in phase_cn else f"{emoji} DEFENSE COMPARISON"
    
    button_style = "primary" if st.session_state.attack_phase == phase_key else "secondary"
    
    if st.sidebar.button(f"{emoji} {phase_en}", key=f"btn_{phase_cn}", type=button_style, use_container_width=True):
        st.session_state.attack_phase = phase_key
        st.rerun()

attack_phase = st.session_state.attack_phase

# ä¾§è¾¹æ çŠ¶æ€æ˜¾ç¤º
st.sidebar.markdown("---")
st.sidebar.markdown("### ğŸ“Š SYSTEM STATUS")

# ç³»ç»ŸçŠ¶æ€æŒ‡ç¤ºå™¨
system_status = {
    "ğŸ”´ TARGET LOCKED": True,
    "ğŸŸ  ATTACK ACTIVE": len(weight_data) > 0,
    "ğŸŸ¢ DATA READY": len(sign_data) > 0,
    "âšª STEALTH MODE": True
}

for status, active in system_status.items():
    color = "#00ff41" if active else "#666"
    st.sidebar.markdown(f'<div style="color: {color}; font-family: \'Fira Code\', monospace;">{status}</div>', unsafe_allow_html=True)

if attack_phase == "ğŸ›¡ï¸ é˜²å¾¡å¯¹æ¯”":
    st.markdown('<div class="attack-phase">ğŸ›¡ï¸ Defense measures and their effects - é˜²å¾¡æ•ˆæœå¯¹æ¯”ä¸æ”»å‡»æ¼”ç¤º</div>', unsafe_allow_html=True)
    
    # æ”»å‡»æ§åˆ¶é¢æ¿
    st.markdown("### âš¡ æ”»å‡»æ§åˆ¶å°")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        if st.button("ğŸš€ å¯åŠ¨å®Œæ•´æ”»å‡»", type="primary"):
            st.session_state.attack_launched = True
            st.session_state.attack_paused = False
            st.session_state.attack_completed = False  # æ¯æ¬¡ç‚¹å‡»éƒ½é‡ç½®ï¼Œä¿è¯è¿›åº¦æ¡æ˜¾ç¤º
            st.session_state.sign_attack_launched = True  # åŒæ­¥è§¦å‘ç¬¦å·æ¢å¤æ”»å‡»
            weights_files = [
                'src/logs/recover_weights_layer_0_20250606_194033.log',
                'src/logs/recover_weights_layer_1_20250606_194140.log',
                'src/logs/recover_weights_layer_2_20250606_194241.log',
                'src/logs/recover_weights_layer_3_20250606_200355.log'
            ]
            # åŠ è½½åŸå§‹æ•°æ®
            base_neurons_list = [load_weights(f) for f in weights_files]
            base_symbolic_data = load_symbolic_data()
            defense = st.session_state.selected_defense
            if defense == "æ— é˜²å¾¡":
                st.session_state.neurons_list = base_neurons_list
                st.session_state.loaded_layers = set(range(len(weights_files)))
                st.session_state.symbolic_data = base_symbolic_data
            else:
                sim_neurons, sim_symbolic = get_simulated_data(defense, base_neurons_list, base_symbolic_data)
                st.session_state.neurons_list = sim_neurons
                st.session_state.loaded_layers = set(range(len(weights_files)))
                st.session_state.symbolic_data = sim_symbolic
            # æ ‡è®°è¯¥é˜²å¾¡å·²æ˜¾ç¤º
            st.session_state.defense_shown[defense] = True
    
    with col2:
        if st.button("â¸ï¸ æš‚åœæ”»å‡»"):
            st.session_state.attack_paused = True
    
    with col3:
        if st.button("ğŸ”„ é‡ç½®æ”»å‡»"):
            st.session_state.attack_launched = False
            st.session_state.attack_paused = False
            st.session_state.attack_completed = False
    
    with col4:
        if st.button("ğŸ“Š æŸ¥çœ‹æŠ¥å‘Š"):
            st.session_state.show_report = True
    
    # æ”»å‡»è¿›åº¦æ¨¡æ‹Ÿ
    if st.session_state.get('attack_launched', False) and not st.session_state.get('attack_completed', False):
        st.markdown("### ğŸ¯ å®æ—¶æ”»å‡»è¿›åº¦")
        
        # --- æ–°å¢ï¼šæ€»è¿›åº¦æ¡ ---
        total_progress_placeholder = st.empty()
        phase1_progress = 0
        phase2_progress = 0
        
        progress_placeholder = st.empty()
        with progress_placeholder.container():
            # é˜¶æ®µ1: æƒé‡æ¢å¤
            st.markdown("#### ğŸ” é˜¶æ®µ1: æƒé‡æ¢å¤æ”»å‡»")
            weight_progress = st.progress(0)
            weight_status = st.empty()
            
            # æ¨¡æ‹Ÿæƒé‡æ¢å¤è¿›åº¦
            import time
            for i in range(0, 101, 2):
                if st.session_state.get('attack_paused', False):
                    weight_status.warning("â¸ï¸ æ”»å‡»å·²æš‚åœ")
                    break
                weight_progress.progress(i / 100)
                phase1_progress = i / 100
                # æ€»è¿›åº¦ = (é˜¶æ®µ1+é˜¶æ®µ2)/2
                total_progress = (phase1_progress + phase2_progress) / 2
                total_progress_placeholder.progress(total_progress, text=f"æ”»å‡»æ€»è¿›åº¦ï¼š{int(total_progress*100)}%")
                if i < 30:
                    weight_status.info(f"ğŸ”„ æ‰«æç›®æ ‡ç¥ç»ç½‘ç»œç»“æ„... ({i}%)")
                elif i < 60:
                    weight_status.info(f"ğŸ¯ è¯†åˆ«å†³ç­–è¾¹ç•Œå¯¹å¶ç‚¹... ({i}%)")
                elif i < 90:
                    weight_status.info(f"âš¡ æå–æƒé‡å‘é‡å‚æ•°... ({i}%)")
                else:
                    weight_status.success(f"âœ… æƒé‡æ¢å¤é˜¶æ®µå®Œæˆ! ({i}%)")
                time.sleep(0.05)
            
            if not st.session_state.get('attack_paused', False):
                # é˜¶æ®µ2: ç¬¦å·æ¢å¤
                st.markdown("#### ğŸ­ é˜¶æ®µ2: ç¬¦å·æ¢å¤æ”»å‡»")
                sign_progress = st.progress(0)
                sign_status = st.empty()
                for j in range(0, 101, 3):
                    if st.session_state.get('attack_paused', False):
                        sign_status.warning("â¸ï¸ æ”»å‡»å·²æš‚åœ")
                        break
                    sign_progress.progress(j / 100)
                    phase2_progress = j / 100
                    total_progress = (phase1_progress + phase2_progress) / 2
                    total_progress_placeholder.progress(total_progress, text=f"æ”»å‡»æ€»è¿›åº¦ï¼š{int(total_progress*100)}%")
                    if j < 25:
                        sign_status.info(f"ğŸ” åˆ†æç¥ç»å…ƒæ¿€æ´»æ¨¡å¼... ({j}%)")
                    elif j < 50:
                        sign_status.info(f"ğŸ—³ï¸ æ‰§è¡Œç»Ÿè®¡æŠ•ç¥¨ç®—æ³•... ({j}%)")
                    elif j < 75:
                        sign_status.info(f"ğŸ“Š è®¡ç®—ç¬¦å·ç½®ä¿¡åº¦... ({j}%)")
                    else:
                        sign_status.success(f"âœ… ç¬¦å·æ¢å¤é˜¶æ®µå®Œæˆ! ({j}%)")
                    time.sleep(0.04)
                if not st.session_state.get('attack_paused', False):
                    # æ”»å‡»å®Œæˆæç¤º
                    total_progress_placeholder.progress(1.0, text="æ”»å‡»æ€»è¿›åº¦ï¼š100%")
                    st.success("ğŸ¯ ç¥ç»ç½‘ç»œå‚æ•°æ¢å¤æ”»å‡»æˆåŠŸå®Œæˆï¼ç›®æ ‡æ¨¡å‹å·²è¢«å®Œå…¨ç ´è§£ï¼")
                    st.balloons()
                    st.session_state.attack_completed = True
    
    # æ”»å‡»ç»Ÿè®¡æ¦‚è§ˆ
    # st.markdown("### ğŸ“Š æ”»å‡»ç»Ÿè®¡æ•°æ®")
    # col1, col2, col3, col4 = st.columns(4)
    # with col1:
    #     total_layers = len(weight_data)
    #     st.markdown(f'<div class="warning-metric">TARGET LAYERS<br>{total_layers}<br><small>Hidden Layers</small></div>', unsafe_allow_html=True)
    # with col2:
    #     total_neurons_weight = sum([data['neurons_extracted'] for data in weight_data.values()])
    #     st.markdown(f'<div class="success-metric">WEIGHTS EXTRACTED<br>{total_neurons_weight}<br><small>Neurons Compromised</small></div>', unsafe_allow_html=True)
    # with col3:
    #     total_neurons_sign = sum([len(layer_data) for layer_data in sign_data.values()])
    #     st.markdown(f'<div class="success-metric">SIGNS ANALYZED<br>{total_neurons_sign}<br><small>Neurons Processed</small></div>', unsafe_allow_html=True)
    # with col4:
    #     avg_success_rate = np.mean([
    #         np.mean([neuron['success_rate'] for neuron in layer_data.values()]) 
    #         for layer_data in sign_data.values() if layer_data
    #     ]) if sign_data else 0
    #     if avg_success_rate > 0.7:
    #         metric_class = "success-metric"
    #     elif avg_success_rate > 0.4:
    #         metric_class = "warning-metric"
    #     else:
    #         metric_class = "danger-metric"
    #     st.markdown(f'<div class="{metric_class}">SUCCESS RATE<br>{avg_success_rate:.1%}<br><small>Attack Efficiency</small></div>', unsafe_allow_html=True)

    # --- åœ¨overviewé¡µé¢ä¸‹æ–¹æ’å…¥é˜²å¾¡å¯¹æ¯”å†…å®¹ ---
    st.markdown('<div class="attack-phase">ğŸ›¡ï¸ é˜²å¾¡æ•ˆæœå¯¹æ¯”</div>', unsafe_allow_html=True)
    st.markdown("""
    <div class="info-box">
    æœ¬é¡µç”¨äºå¯¹æ¯”ä¸åŒé˜²å¾¡ç­–ç•¥ä¸‹çš„æ”»å‡»æˆåŠŸç‡ã€‚ä½ å¯ä»¥åˆ‡æ¢ä¸åŒé˜²å¾¡æ–¹å¼ï¼ŒæŸ¥çœ‹å…¶å¯¹æ”»å‡»çš„æŠ‘åˆ¶æ•ˆæœã€‚
    </div>
    """, unsafe_allow_html=True)

    defense_options = [
        "æ— é˜²å¾¡",
        "è¾“å‡ºæ‰°åŠ¨",
        "è¾“å…¥å˜æ¢",
        "æ¨¡å‹å‚æ•°æ‰°åŠ¨"
    ]
    if 'defense_shown' not in st.session_state:
        st.session_state.defense_shown = {k: False for k in defense_options}
    if 'selected_defense' not in st.session_state:
        st.session_state.selected_defense = defense_options[0]
    cols = st.columns(4)
    for idx, label in enumerate(defense_options):
        btn_style = f"background-color:#00ff41;color:#111;font-weight:bold;" if st.session_state.selected_defense==label else "background-color:#181c20;color:#00ff41;"
        if cols[idx].button(label, key=f'defense_btn_{idx}', help=label, use_container_width=True):
            st.session_state.selected_defense = label

    selected_defense = st.session_state.selected_defense

    defense_results = {
        "æ— é˜²å¾¡": {"rate": 0.95, "desc": "æœªé‡‡å–ä»»ä½•é˜²å¾¡æªæ–½"},
        "è¾“å‡ºæ‰°åŠ¨": {"rate": 0.60, "desc": "åœ¨è¾“å‡ºç«¯æ·»åŠ å¾®å°å™ªå£°"},
        "è¾“å…¥å˜æ¢": {"rate": 0.40, "desc": "å¯¹è¾“å…¥æ•°æ®åšå˜æ¢æ‰°åŠ¨"},
        "æ¨¡å‹å‚æ•°æ‰°åŠ¨": {"rate": 0.25, "desc": "å¯¹æ¨¡å‹å‚æ•°åŠ å™ªå£°"},
    }

    rate_cells = []
    for idx, label in enumerate(defense_options):
        if st.session_state.defense_shown.get(label, False):
            rate = f"{int(defense_results[label]['rate']*100)}%"
        else:
            rate = "-"
        rate_cells.append(rate)
    st.markdown('''
    <style>
    .defense-table {{border-collapse:collapse; width:70%; margin: 0 auto 24px auto; font-family: 'Fira Mono', 'Consolas', monospace;}}
    .defense-table th, .defense-table td {{border:2px solid #00ff41; padding:10px 18px; text-align:center; font-size:1.1em;}}
    .defense-table th {{background:rgba(0,255,65,0.12); color:#00ff41;}}
    .defense-table tr:nth-child(even) {{background:rgba(0,255,65,0.04);}}
    .defense-table tr.selected {{background:rgba(0,255,65,0.18)!important; color:#fff; font-weight:bold;}}
    .defense-table td.rate {{font-weight:bold;}}
    .defense-table td.rate-high {{color:#ff2222;}}
    .defense-table td.rate-mid {{color:#ffc107;}}
    .defense-table td.rate-low {{color:#00ff41;}}
    </style>
    <table class="defense-table">
      <tr>
        <th>é˜²å¾¡æ–¹å¼</th>
        <th>æ”»å‡»æˆåŠŸç‡</th>
        <th>è¯´æ˜</th>
      </tr>
      <tr class="{sel0}">
        <td>æ— é˜²å¾¡</td>
        <td class="rate rate-high">{rate0}</td>
        <td>æœªé‡‡å–ä»»ä½•é˜²å¾¡æªæ–½</td>
      </tr>
      <tr class="{sel1}">
        <td>è¾“å‡ºæ‰°åŠ¨</td>
        <td class="rate rate-mid">{rate1}</td>
        <td>åœ¨è¾“å‡ºç«¯æ·»åŠ å¾®å°å™ªå£°</td>
      </tr>
      <tr class="{sel2}">
        <td>è¾“å…¥å˜æ¢</td>
        <td class="rate rate-mid">{rate2}</td>
        <td>å¯¹è¾“å…¥æ•°æ®åšå˜æ¢æ‰°åŠ¨</td>
      </tr>
      <tr class="{sel3}">
        <td>æ¨¡å‹å‚æ•°æ‰°åŠ¨</td>
        <td class="rate rate-low">{rate3}</td>
        <td>å¯¹æ¨¡å‹å‚æ•°åŠ å™ªå£°</td>
      </tr>
    </table>
    '''.format(
        sel0="selected" if selected_defense==defense_options[0] else "",
        sel1="selected" if selected_defense==defense_options[1] else "",
        sel2="selected" if selected_defense==defense_options[2] else "",
        sel3="selected" if selected_defense==defense_options[3] else "",
        rate0=rate_cells[0],
        rate1=rate_cells[1],
        rate2=rate_cells[2],
        rate3=rate_cells[3],
    ), unsafe_allow_html=True)

    st.markdown('''
    <div style="border-radius: 8px; border: 1.5px solid #00ff41; background:rgba(10,20,40,0.92); padding: 14px 20px; margin: 12px 0 0 0; color:#00ff41; font-family: 'Fira Mono', 'Consolas', monospace; font-size: 1.05em;">
    <b>ç»“è®ºï¼š</b>å¯ä»¥çœ‹åˆ°ï¼Œä¸‰ç§é˜²å¾¡æ–¹å¼å‡èƒ½æœ‰æ•ˆé™ä½æ”»å‡»æˆåŠŸç‡ï¼Œ<b style="color:#00ff41;">æ¨¡å‹å‚æ•°æ‰°åŠ¨</b>é˜²å¾¡æ•ˆæœæœ€ä½³ã€‚å»ºè®®å®é™…éƒ¨ç½²æ—¶ç»“åˆå¤šç§é˜²å¾¡æ‰‹æ®µä»¥æå‡å®‰å…¨æ€§ã€‚
    </div>
    ''', unsafe_allow_html=True)

elif attack_phase == "âš¡ ç¬¬ä¸€é˜¶æ®µï¼šæƒé‡æ¢å¤":
    st.markdown('<div class="attack-phase">âš¡ PHASE 1: SIGNATURE RECOVERY - æƒé‡å‘é‡æ¢å¤</div>', unsafe_allow_html=True)

    # ====== äº¤äº’æ§ä»¶ï¼ˆ3Då›¾ä¸Šæ–¹ï¼‰ ======
    weights_files = [
        'src/logs/recover_weights_layer_0_20250606_194033.log',
        'src/logs/recover_weights_layer_1_20250606_194140.log',
        'src/logs/recover_weights_layer_2_20250606_194241.log',
        'src/logs/recover_weights_layer_3_20250606_200355.log'
    ]
    selected_file = st.selectbox('é€‰æ‹©è¦åŠ è½½çš„å±‚', weights_files)
    if 'loaded_layers' not in st.session_state:
        st.session_state.loaded_layers = set()
    if 'neurons_list' not in st.session_state:
        st.session_state.neurons_list = [None] * len(weights_files)
    if st.button('åŠ è½½é€‰ä¸­çš„å±‚'):
        layer_idx = weights_files.index(selected_file)
        progress_bar = st.progress(0)
        status_text = st.empty()
        import time
        for i in range(0, 101, 10):
            progress_bar.progress(i / 100)
            status_text.info(f"æ­£åœ¨åŠ è½½ç¬¬ {layer_idx} å±‚... ({i}%)")
            time.sleep(0.03)
        st.session_state.loaded_layers.add(layer_idx)
        st.session_state.neurons_list[layer_idx] = load_weights(selected_file)
        progress_bar.progress(1.0)
        status_text.success(f"âœ… æˆåŠŸåŠ è½½ç¬¬ {layer_idx} å±‚")
    if st.button('é‡ç½®æ‰€æœ‰å±‚'):
        st.session_state.loaded_layers.clear()
        st.session_state.neurons_list = [None] * len(weights_files)
        st.success("å·²é‡ç½®æ‰€æœ‰å±‚")
    connection_mode = st.radio(
        "é€‰æ‹©è¿çº¿æ˜¾ç¤ºæ¨¡å¼",
        ["æ˜¾ç¤ºæœ€é‡è¦çš„5æ¡è¿çº¿", "æ˜¾ç¤ºæ‰€æœ‰è¿çº¿"],
        index=0
    )
    show_all_connections = connection_mode == "æ˜¾ç¤ºæ‰€æœ‰è¿çº¿"

    # ====== 3Då›¾å¯è§†åŒ– ======
    fig = create_3d_network(
        st.session_state.neurons_list,
        st.session_state.loaded_layers,
        show_all_connections=show_all_connections,
        symbolic_data=None  # phase1é¡µé¢ä¸æ˜¾ç¤ºç¬¦å·æ¢å¤
    )
    st.markdown("### ğŸ§  3Dç¥ç»ç½‘ç»œæƒé‡æ¢å¤å¯è§†åŒ–")
    st.plotly_chart(fig, use_container_width=True, height=800)

    # ====== è¯¦ç»†ç¥ç»å…ƒä¿¡æ¯ï¼ˆ3Då›¾ä¸‹æ–¹ï¼‰ ======
    for layer_idx, neurons in enumerate(st.session_state.neurons_list):
        if neurons is None:
            continue
        st.header(f'Layer {layer_idx} ç»Ÿè®¡')
        is_loaded = layer_idx in st.session_state.loaded_layers
        st.write(f'çŠ¶æ€: {"å·²åŠ è½½" if is_loaded else "æœªåŠ è½½"}')
        errors = [n.error for n in neurons]
        singular_values = [n.singular_values[0] for n in neurons if len(n.singular_values) > 0]
        st.write(f'ç¥ç»å…ƒæ•°é‡: {len(neurons)}')
        st.write(f'å¹³å‡è¯¯å·®: {np.mean(errors):.2e}')
        st.write(f'æœ€å¤§è¯¯å·®: {np.max(errors):.2e}')
        st.write(f'æœ€å°è¯¯å·®: {np.min(errors):.2e}')
        if singular_values:
            st.write(f'å¹³å‡æœ€å¤§å¥‡å¼‚å€¼: {np.mean(singular_values):.2f}')
        st.write('---')
        if st.checkbox(f'æ˜¾ç¤ºLayer {layer_idx}çš„ç¥ç»å…ƒè¯¦æƒ…'):
            for i, neuron in enumerate(neurons):
                with st.expander(f'Neuron {i} (Cluster {neuron.cluster_id})'):
                    st.write(f'Cluster ID: {neuron.cluster_id}')
                    st.write(f'æƒé‡æ¢å¤è¯¯å·®: {neuron.error:.2e}')
                    if len(neuron.singular_values) > 0:
                        st.write(f'æœ€å¤§å¥‡å¼‚å€¼: {neuron.singular_values[0]:.2f}')

elif attack_phase == "ğŸ” ç¬¬äºŒé˜¶æ®µï¼šç¬¦å·æ¢å¤":
    st.markdown('<div class="attack-phase">ğŸ” PHASE 2: SIGN RECOVERY - ç¬¦å·å‘é‡ç ´è§£</div>', unsafe_allow_html=True)
    
    # æ·»åŠ å¯åŠ¨ç¬¦å·æ¢å¤æ”»å‡»çš„æŒ‰é’®
    if st.button("ğŸ­ å¯åŠ¨ç¬¦å·æ¢å¤æ”»å‡»", type="primary"):
        st.session_state.sign_attack_launched = True
    
    # ç¬¦å·æ¢å¤æ”»å‡»è¿›åº¦
    if hasattr(st.session_state, 'sign_attack_launched') and st.session_state.sign_attack_launched:
        st.markdown("### ğŸ”„ ç¬¦å·æ¢å¤æ”»å‡»è¿›è¡Œä¸­...")
        
        # ä¸‰ä¸ªå­æ­¥éª¤çš„è¿›åº¦æ¡
        step1_progress = st.progress(0)
        step1_status = st.empty()
        
        import time
        # æ­¥éª¤1: æƒé‡åˆ†æ
        for i in range(0, 101, 6):
            step1_progress.progress(i / 100)
            step1_status.info(f"ğŸ“‚ STEP 1: åŠ è½½é˜¶æ®µ1æ¢å¤çš„æƒé‡å‘é‡... ({i}%)")
            time.sleep(0.02)
        step1_status.success("âœ… STEP 1: æƒé‡å‘é‡åˆ†æå®Œæˆ")
        
        step2_progress = st.progress(0)
        step2_status = st.empty()
        
        # æ­¥éª¤2: ç»Ÿè®¡æµ‹è¯•
        for i in range(0, 101, 2):
            step2_progress.progress(i / 100)
            if i < 50:
                step2_status.info(f"ğŸ§ª STEP 2: åˆ†æç¥ç»å…ƒæ¿€æ´»æ¨¡å¼... ({i}%)")
            else:
                step2_status.info(f"ğŸ“Š STEP 2: æµ‹é‡è·ç¦»åˆ†å¸ƒç»Ÿè®¡... ({i}%)")
            time.sleep(0.04)
        step2_status.success("âœ… STEP 2: ç»Ÿè®¡æµ‹è¯•å®Œæˆ")
        
        step3_progress = st.progress(0)
        step3_status = st.empty()
        
        # æ­¥éª¤3: ç¬¦å·ç¡®å®š
        for i in range(0, 101, 4):
            step3_progress.progress(i / 100)
            step3_status.info(f"ğŸ¯ STEP 3: ç¡®å®šæƒé‡ç¬¦å·ï¼ˆæ­£/è´Ÿï¼‰... ({i}%)")
            time.sleep(0.03)
        step3_status.success("âœ… STEP 3: ç¬¦å·ç¡®å®šå®Œæˆ")
        
        st.success("ğŸ‰ ç¬¦å·æ¢å¤æ”»å‡»å®Œæˆï¼æˆåŠŸç¡®å®šæ‰€æœ‰æƒé‡ç¬¦å·ï¼")
        
        # æ˜¾ç¤ºæ¨¡æ‹Ÿçš„ç¬¦å·æ¢å¤ç»Ÿè®¡
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("ç¬¦å·æ¢å¤æˆåŠŸç‡", "94.7%", "â¬† +2.1%")
        with col2:
            st.metric("å¤„ç†ç¥ç»å…ƒæ•°", "512", "â¬† +256")
        with col3:
            st.metric("å¹³å‡ç½®ä¿¡åº¦", "0.892", "â¬† +0.047")
            
        st.session_state.sign_attack_launched = False
    
    st.markdown("""
    <div class="hacker-box">
    <strong>[ ADVANCED CRYPTANALYSIS MODE ]</strong><br><br>
    STEP 1: WEIGHT_ANALYSIS.exe<br>
    â””â”€â”€ Loading recovered weight vectors from Phase 1...<br>
    â””â”€â”€ Status: <span style="color: #00ff41;">READY</span><br><br>
    
    STEP 2: STATISTICAL_TESTING.exe<br>
    â””â”€â”€ Analyzing neuron activation patterns...<br>
    â””â”€â”€ Measuring distance distributions...<br>
    â””â”€â”€ Status: <span style="color: #ffc107;">STANDBY</span><br><br>
    
    STEP 3: SIGN_DETERMINATION.exe<br>
    â””â”€â”€ Determining positive/negative weight signs...<br>
    â””â”€â”€ Status: <span style="color: #6c757d;">PENDING</span>
    </div>
    """, unsafe_allow_html=True)
    
    if sign_data:
        # å±‚å’Œç¥ç»å…ƒé€‰æ‹©
        available_layers = list(sign_data.keys())
        selected_layer = st.selectbox("é€‰æ‹©è¦åˆ†æçš„å±‚", available_layers)
        
        if selected_layer in sign_data and sign_data[selected_layer]:
            available_neurons = list(sign_data[selected_layer].keys())
            selected_neuron = st.selectbox("é€‰æ‹©è¦åˆ†æçš„ç¥ç»å…ƒ", available_neurons)
            
            neuron_data = sign_data[selected_layer][selected_neuron]
            
            # ç¥ç»å…ƒåˆ†æç»“æœ
            col1, col2, col3 = st.columns(3)
            
            with col1:
                success_rate = neuron_data['success_rate']
                if success_rate > 0.7:
                    st.markdown(f'<div class="success-metric">ç¬¦å·æ¢å¤æˆåŠŸç‡<br>{success_rate:.1%}</div>', unsafe_allow_html=True)
                else:
                    st.markdown(f'<div class="danger-metric">ç¬¦å·æ¢å¤æˆåŠŸç‡<br>{success_rate:.1%}</div>', unsafe_allow_html=True)
            
            with col2:
                st.metric("å®éªŒæ€»æ•°", neuron_data['total_experiments'])
            
            with col3:
                st.metric("æˆåŠŸæŠ•ç¥¨æ•°", neuron_data['successful_votes'])
            
            # è¯¦ç»†åˆ†æå›¾è¡¨
            df = neuron_data['data']
            
            # è·ç¦»æ¯”ç‡åˆ†å¸ƒ
            fig1 = px.histogram(
                df, x='dOFF/dON', 
                title=f"Layer {selected_layer} Neuron {selected_neuron} - è·ç¦»æ¯”ç‡åˆ†å¸ƒ",
                labels={'dOFF/dON': 'dOFF/dON æ¯”ç‡', 'count': 'é¢‘æ¬¡'},
                color='Vote dOFF>dON',
                nbins=30
            )
            fig1.add_vline(x=1, line_dash="dash", line_color="red", 
                          annotation_text="å†³ç­–é˜ˆå€¼")
            st.plotly_chart(fig1, use_container_width=True)
            
            # å®éªŒè¿›åº¦éšæ—¶é—´å˜åŒ–
            if len(df) > 0:
                df['cumulative_success_rate'] = df['Vote dOFF>dON'].cumsum() / np.arange(1, len(df) + 1)
            else:
                df['cumulative_success_rate'] = []
            
            fig2 = px.line(
                df, x='nExp', y='cumulative_success_rate',
                title=f"ç¬¦å·æ¢å¤æˆåŠŸç‡éšå®éªŒè¿›åº¦å˜åŒ–",
                labels={'nExp': 'å®éªŒç¼–å·', 'cumulative_success_rate': 'ç´¯ç§¯æˆåŠŸç‡'}
            )
            fig2.add_hline(y=0.5, line_dash="dash", line_color="red",
                          annotation_text="éšæœºçŒœæµ‹æ°´å¹³")
            st.plotly_chart(fig2, use_container_width=True)
            
            # è¯¦ç»†æ•°æ®è¡¨
            with st.expander("æŸ¥çœ‹è¯¦ç»†å®éªŒæ•°æ®"):
                st.dataframe(df[['nExp', 'dON', 'dOFF', 'dOFF/dON', 'Vote dOFF>dON', 'SUCCESS']].head(20))
        
        else:
            st.warning(f"Layer {selected_layer} æ²¡æœ‰ç¬¦å·æ¢å¤æ•°æ®ã€‚")
    else:
        st.warning("æ²¡æœ‰æ‰¾åˆ°ç¬¦å·æ¢å¤æ•°æ®ï¼Œè¯·ç¡®ä¿src/layerID_*ç›®å½•ä¸‹æœ‰ç›¸å…³æ•°æ®æ–‡ä»¶ã€‚")

elif attack_phase == "ğŸ›°ï¸ æœ€ç»ˆç½‘ç»œ":
    st.markdown('<div class="attack-phase">ğŸ›°ï¸ FINAL RECOVERED NETWORK - æœ€ç»ˆæ¢å¤ç½‘ç»œå…¨æ™¯</div>', unsafe_allow_html=True)
    st.markdown("""
    <div class="info-box">
    è¿™æ˜¯ç»¼åˆäº† <strong>æƒé‡æ¢å¤(Phase 1)</strong> å’Œ <strong>ç¬¦å·æ¢å¤(Phase 2)</strong> ä¸¤ä¸ªé˜¶æ®µçš„æœ€ç»ˆæˆæœã€‚
    ç½‘ç»œä¸­çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½æ ¹æ®å…¶æœ€ç»ˆæ¢å¤çŠ¶æ€è¿›è¡Œäº†ç€è‰²å’Œæ ‡è®°ï¼š<br>
    - <span style="color:#00ff41;">â– </span> ç»¿è‰²èŠ‚ç‚¹: æƒé‡å’Œç¬¦å·å‡æˆåŠŸæ¢å¤ã€‚<br>
    - <span style="color:#ff2222;">â– </span> çº¢è‰²èŠ‚ç‚¹: ç¬¦å·æ¢å¤å¤±è´¥ã€‚
    </div>
    """, unsafe_allow_html=True)

    # --- æ”¹è¿›çš„æ•°æ®åŠ è½½é€»è¾‘ ---
    # 1. å°è¯•åŠ è½½çœŸå®æ•°æ®
    real_neurons_list = load_weights_parallel([
        os.path.join(_SCRIPT_DIR, 'src/logs/recover_weights_layer_0_20250606_194033.log'),
        os.path.join(_SCRIPT_DIR, 'src/logs/recover_weights_layer_1_20250606_194140.log'),
        os.path.join(_SCRIPT_DIR, 'src/logs/recover_weights_layer_2_20250606_194241.log'),
        os.path.join(_SCRIPT_DIR, 'src/logs/recover_weights_layer_3_20250606_200355.log')
    ])
    real_symbolic_data = load_symbolic_data()

    # 2. æ£€æŸ¥çœŸå®æ•°æ®æ˜¯å¦æœ‰æ•ˆ
    # æˆ‘ä»¬è®¤ä¸ºï¼Œåªè¦ç¬¦å·æ¢å¤æ•°æ®ä¸ºç©ºï¼Œå°±ä»£è¡¨çœŸå®æ•°æ®ä¸å®Œæ•´ï¼Œåº”åˆ‡æ¢åˆ°æ¼”ç¤ºæ¨¡å¼
    if real_symbolic_data:
        st.success("âœ… æˆåŠŸåŠ è½½çœŸå®ç½‘ç»œæ•°æ®ï¼")
        neurons_list = real_neurons_list
        symbolic_data = real_symbolic_data
    else:
        # 3. å¦‚æœçœŸå®æ•°æ®æ— æ•ˆï¼Œåˆ™å›é€€åˆ°æ¨¡æ‹Ÿæ•°æ®
        st.warning("âš ï¸ æœªæ‰¾åˆ°å®Œæ•´çš„çœŸå®æ•°æ®ï¼Œå·²è‡ªåŠ¨åˆ‡æ¢åˆ°æ¼”ç¤ºæ¨¡å¼ã€‚")
        if 'mock_neurons' not in st.session_state:
            st.session_state.mock_neurons = generate_mock_neurons_list()
        if 'mock_symbolic' not in st.session_state:
            st.session_state.mock_symbolic = generate_mock_symbolic_data()
        
        neurons_list = st.session_state.mock_neurons
        symbolic_data = st.session_state.mock_symbolic
    # --- æ•°æ®åŠ è½½é€»è¾‘ç»“æŸ ---

    if any(neurons is not None for neurons in neurons_list):
        # 3D å¯è§†åŒ–
        st.markdown('<h3 class="sub-header">ğŸ§  3Dç½‘ç»œæ¢å¤ç»“æœ</h3>', unsafe_allow_html=True)
        show_all_connections_3d = st.toggle("æ˜¾ç¤ºæ‰€æœ‰ç¥ç»å…ƒè¿æ¥ (3D)", value=False, key="3d_connections_final")
        
        fig_3d = create_3d_network(
            neurons_list,
            loaded_layers=set(range(len(neurons_list))),  # æ ‡è®°æ‰€æœ‰å±‚ä¸ºå·²åŠ è½½
            show_all_connections=show_all_connections_3d,
            symbolic_data=symbolic_data,
            is_final_view=True
        )
        st.plotly_chart(fig_3d, use_container_width=True, height=800)

        # --- æ–°å¢ï¼šç¾è§‚çš„å›¾ç‰‡ä¿¡æ¯è¯´æ˜ ---
        st.markdown('''
        <div style="border-radius: 10px; border: 2px solid #00ff41; background:rgba(10,20,40,0.95); padding: 18px 24px; margin: 18px 0 28px 0; color:#00ff41; font-family: 'Fira Mono', 'Consolas', monospace; font-size: 1.1em;">
        <b>ğŸ§  3Dç½‘ç»œå›¾è¯´æ˜ï¼š</b><br>
        <ul style="margin-top: 8px;">
        <li><b style="color:#00ff41;">ç»¿è‰²èŠ‚ç‚¹</b>ï¼šæƒé‡å’Œç¬¦å·å‡æ¢å¤æˆåŠŸ</li>
        <li><b style="color:#ff2222;">çº¢è‰²èŠ‚ç‚¹</b>ï¼šç¬¦å·æ¢å¤å¤±è´¥</li>
        <li>èŠ‚ç‚¹å¤§å°ï¼šç¬¦å·æ¢å¤ç½®ä¿¡åº¦ <b>(dOFF/dON)</b>ï¼Œæ¯”å€¼è¶Šå¤§èŠ‚ç‚¹è¶Šå¤§</li>
        <li>æ‚¬æµ®èŠ‚ç‚¹å¯æŸ¥çœ‹è¯¦ç»†æ¢å¤ä¿¡æ¯</li>
        <li>å¯åˆ‡æ¢"æ˜¾ç¤ºæ‰€æœ‰ç¥ç»å…ƒè¿æ¥"ä»¥æŸ¥çœ‹å®Œæ•´ç½‘ç»œç»“æ„</li>
        </ul>
        </div>
        ''', unsafe_allow_html=True)

        # ====== ç¥ç»å…ƒè¯¦ç»†ä¿¡æ¯é¢æ¿ ======
        st.markdown('<h3 class="sub-header">ğŸ§¬ ç¥ç»å…ƒè¯¦ç»†ä¿¡æ¯é¢æ¿</h3>', unsafe_allow_html=True)
        for layer_idx, neurons in enumerate(neurons_list):
            if neurons is None:
                continue
            st.header(f'Layer {layer_idx} ç»Ÿè®¡')
            if st.checkbox(f'æ˜¾ç¤ºLayer {layer_idx}çš„ç¥ç»å…ƒè¯¦æƒ…', key=f'final_layer_{layer_idx}'):
                for i, neuron in enumerate(neurons):
                    with st.expander(f'Neuron {i} (Cluster {neuron.cluster_id})'):
                        st.write(f'Cluster ID: {neuron.cluster_id}')
                        st.write(f'æƒé‡æ¢å¤è¯¯å·®: {neuron.error:.2e}')
                        if len(neuron.singular_values) > 0:
                            st.write(f'æœ€å¤§å¥‡å¼‚å€¼: {neuron.singular_values[0]:.2f}')
                        symbolic_info = symbolic_data.get((layer_idx, i))
                        if symbolic_info:
                            if symbolic_info.get('success'):
                                st.write('ç¬¦å·æ¢å¤: âœ… æˆåŠŸ')
                                st.write(f'dOFF/dON: {symbolic_info["ratio"]:.2f}')
                                # å®‰å…¨æ˜¾ç¤ºè§’åº¦ä¿¡æ¯
                                dxon_angle = symbolic_info.get("dxONAngle", float('nan'))
                                dxoff_angle = symbolic_info.get("dxOFFAngle", float('nan'))
                                st.write(f'ONè§’åº¦: {dxon_angle:.1f}Â°' if not math.isnan(dxon_angle) else 'ONè§’åº¦: N/A')
                                st.write(f'OFFè§’åº¦: {dxoff_angle:.1f}Â°' if not math.isnan(dxoff_angle) else 'OFFè§’åº¦: N/A')
                            else:
                                st.write('ç¬¦å·æ¢å¤: âŒ å¤±è´¥')
                                st.write('dOFF/dON: -')
                                st.write('ONè§’åº¦: -')
                                st.write('OFFè§’åº¦: -')
                        else:
                            st.write('ç¬¦å·æ¢å¤: æœªæ£€æµ‹åˆ°æ•°æ®')
    else:
        st.warning("æœªèƒ½åŠ è½½ä»»ä½•ç½‘ç»œæ•°æ®ã€‚è¯·æ£€æŸ¥æ—¥å¿—æ–‡ä»¶è·¯å¾„æ˜¯å¦æ­£ç¡®ã€‚")

elif attack_phase == "ğŸ“Š æ”»å‡»æ•ˆæœåˆ†æ":
    st.markdown('<div class="attack-phase">ğŸ“Š ATTACK ANALYSIS - å®‰å…¨å½±å“è¯„ä¼°ä¸åæœåˆ†æ</div>', unsafe_allow_html=True)
    
    # æ”»å‡»æˆåŠŸç‡åˆ†æ
    st.markdown("### ğŸ¯ æ”»å‡»æˆåŠŸç‡ç»Ÿè®¡")
    
    if weight_data and sign_data:
        # æƒé‡æ¢å¤æˆåŠŸç‡
        weight_success_data = []
        for layer_id, data in weight_data.items():
            weight_success_data.append({
                'Layer': f'Layer {layer_id}',
                'Extracted Neurons': data['neurons_extracted'],
                'Average Error': np.mean(data['errors']) if data['errors'] else 0
            })
        
        df_weight = pd.DataFrame(weight_success_data)
        
        col1, col2 = st.columns(2)
        
        with col1:
            fig1 = px.bar(df_weight, x='Layer', y='Extracted Neurons',
                         title="å„å±‚æƒé‡æ¢å¤æˆåŠŸçš„ç¥ç»å…ƒæ•°é‡")
            st.plotly_chart(fig1, use_container_width=True)
        
        with col2:
            fig2 = px.bar(df_weight, x='Layer', y='Average Error',
                         title="å„å±‚æƒé‡æ¢å¤å¹³å‡è¯¯å·®", log_y=True)
            st.plotly_chart(fig2, use_container_width=True)
        
        # ç¬¦å·æ¢å¤æˆåŠŸç‡
        st.markdown("### ğŸ” ç¬¦å·æ¢å¤è¯¦ç»†åˆ†æ")
        
        sign_success_data = []
        for layer_id, layer_data in sign_data.items():
            for neuron_id, neuron_data in layer_data.items():
                sign_success_data.append({
                    'Layer': f'Layer {layer_id}',
                    'Neuron': neuron_id,
                    'Success Rate': neuron_data['success_rate'],
                    'Total Experiments': neuron_data['total_experiments'],
                    'Avg Ratio': neuron_data['avg_ratio']
                })
        
        if sign_success_data:
            df_sign = pd.DataFrame(sign_success_data)
            
            # æˆåŠŸç‡åˆ†å¸ƒ
            fig3 = px.histogram(df_sign, x='Success Rate', nbins=20,
                              title="ç¬¦å·æ¢å¤æˆåŠŸç‡åˆ†å¸ƒ")
            fig3.add_vline(x=0.5, line_dash="dash", line_color="red",
                          annotation_text="éšæœºæ°´å¹³")
            st.plotly_chart(fig3, use_container_width=True)
            
            # å„å±‚æˆåŠŸç‡å¯¹æ¯”
            layer_stats = df_sign.groupby('Layer')['Success Rate'].agg(['mean', 'std', 'count']).reset_index()
            
            fig4 = px.bar(layer_stats, x='Layer', y='mean', error_y='std',
                         title="å„å±‚ç¬¦å·æ¢å¤å¹³å‡æˆåŠŸç‡ï¼ˆå«æ ‡å‡†å·®ï¼‰")
            fig4.add_hline(y=0.5, line_dash="dash", line_color="red",
                          annotation_text="éšæœºæ°´å¹³")
            st.plotly_chart(fig4, use_container_width=True)
    
    # å®‰å…¨å½±å“è¯„ä¼°
    st.markdown("### âš ï¸ å®‰å…¨å½±å“è¯„ä¼°")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("""
        **æ”»å‡»æˆåŠŸçš„åæœï¼š**
        - âœ… å®Œå…¨æ¢å¤æ¨¡å‹å‚æ•°
        - âœ… å¯ä»¥é‡å»ºå®Œæ•´æ¨¡å‹
        - âœ… å¯ä»¥è¿›è¡Œåé—¨æ”»å‡»
        - âœ… å¯ä»¥ç”Ÿæˆå¯¹æŠ—æ ·æœ¬
        - âœ… å¯ä»¥åˆ†ææ¨¡å‹å¼±ç‚¹
        """)
    
    with col2:
        st.markdown("""
        **é˜²æŠ¤å»ºè®®ï¼š**
        - ğŸ›¡ï¸ é™åˆ¶æŸ¥è¯¢æ¬¡æ•°
        - ğŸ›¡ï¸ æ·»åŠ å™ªå£°é˜²æŠ¤
        - ğŸ›¡ï¸ ä½¿ç”¨å·®åˆ†éšç§
        - ğŸ›¡ï¸ æ¨¡å‹æ°´å°æŠ€æœ¯
        - ğŸ›¡ï¸ æŸ¥è¯¢è¡Œä¸ºç›‘æ§
        """)
    
    # æ¨¡æ‹Ÿåé—¨æ”»å‡»æ¼”ç¤º
    st.markdown("### ğŸ­ åé—¨æ”»å‡»æ¼”ç¤º")
    
    st.markdown("""
    <div class="info-box">
    <strong>æ”»å‡»æµç¨‹æ¼”ç¤ºï¼š</strong><br>
    1. ä½¿ç”¨æ¢å¤çš„å‚æ•°é‡å»ºæ¨¡å‹<br>
    2. åˆ†æå†³ç­–è¾¹ç•Œæ‰¾åˆ°è„†å¼±ç‚¹<br>
    3. è®¾è®¡ç‰¹å®šè§¦å‘å™¨ï¼ˆå¦‚ç‰¹æ®Šåƒç´ æ¨¡å¼ï¼‰<br>
    4. éªŒè¯åé—¨æ”»å‡»æ•ˆæœ
    </div>
    """, unsafe_allow_html=True)
    
    # åˆ›å»ºæ¨¡æ‹Ÿçš„æ”»å‡»æ•ˆæœå›¾
    st.markdown("#### æ¨¡æ‹Ÿæ”»å‡»å‰åå¯¹æ¯”")
    
    # ç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®
    np.random.seed(42)
    normal_accuracy = np.random.normal(0.52, 0.02, 100)
    backdoor_accuracy = np.random.normal(0.05, 0.01, 100)  # åé—¨è§¦å‘æ—¶å‡†ç¡®ç‡æ€¥å‰§ä¸‹é™
    
    attack_demo_data = pd.DataFrame({
        'Test Type': ['æ­£å¸¸æµ‹è¯•'] * 100 + ['åé—¨è§¦å‘'] * 100,
        'Accuracy': np.concatenate([normal_accuracy, backdoor_accuracy])
    })
    
    fig_attack = px.box(attack_demo_data, x='Test Type', y='Accuracy',
                       title="åé—¨æ”»å‡»æ•ˆæœæ¼”ç¤º")
    fig_attack.update_yaxes(range=[0, 1])
    st.plotly_chart(fig_attack, use_container_width=True)

# é¡µè„šä¿¡æ¯
st.markdown("""
<div class="footer">
    <div style="font-family: 'Orbitron', monospace; margin-bottom: 1rem;">
        âš¡ NEURAL NETWORK EXTRACTION PLATFORM âš¡
    </div>
    <div style="font-family: 'Fira Code', monospace;">
        [ CLASSIFIED ] Based on EUROCRYPT 2024 Research | DNN Parameter Recovery Attack Demo<br>
        <a href="https://github.com/google-research/cryptanalytic-model-extraction" target="_blank">>>> ACCESS_ORIGINAL_PROJECT.exe <<<</a><br>
        <small style="color: #666;">Security Research Use Only - Educational Purposes</small>
    </div>
</div>
""", unsafe_allow_html=True)


